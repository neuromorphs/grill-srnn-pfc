# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/03_simplest_srnn_dms.ipynb (unless otherwise specified).

__all__ = ['DMSTask', 'SpatialDMSSimple']

# Cell
import numpy as np
import nengo
import matplotlib.pyplot as plt


class DMSTask:
    phase_names = ['isi', 'cue', 'delay1', 'sample', 'delay2', 'response']
    phase_durs = [1.0, 0.5, 1.5, 0.5, 1.5, 1.0]

    def __init__(self, gen_trials_per_cond=5, cond_seed=1337):
        self.cumulative_durs = np.cumsum(self.phase_durs)
        self.trial_dur = self.cumulative_durs[-1]
        self.cue_locs = DMSTask.cue_locations()
        self.targs, self.matches = self.gen_trial_conditions(n_trials_per_cond=gen_trials_per_cond,
                                                             seed=cond_seed)

    @staticmethod
    def cue_locations(stim_x=1/np.sqrt(2), stim_y=1/np.sqrt(2)):
        """
        Visual stimulus location: x, y. Will be 0, 0 except during Cue and Sample
        periods. During Cue it will be set to one of 8 possible values on the grid,
        except the centre position.
        """
        return np.array([[-stim_x,  stim_y], [0.0,  stim_y], [stim_x, stim_y],
                         [-stim_x,     0.0],                 [stim_x,    0.0],
                         [-stim_x, -stim_y], [0.0, -stim_y], [stim_x, -stim_y]])

    def gen_trial_conditions(self, n_trials_per_cond=5, seed=1337):
        """
        total trials = n_trials_per_cond x 8 stim_locs x 2 match-or-mismatch
        """
        n_locs = len(self.cue_locs)
        result = np.tile(np.arange(n_locs * 2), n_trials_per_cond)
        rng = np.random.default_rng(seed=seed)
        rng.shuffle(result)
        return result % n_locs, 1 - 2*(result >= n_locs)

    def gate_signal(self, t):
        """
        Fixation point acts as a hold signal. We'll just use a 1-d value: -1 for hold, +1 for go.
        """
        return 1 - 2 * ((t % self.trial_dur) < self.cumulative_durs[-2])

    def stim_signal(self, t):
        trial_ix = int(np.floor(t / self.trial_dur)) % len(self.targs)
        t_trial = t % self.trial_dur
        is_cue = self.cumulative_durs[0] <= t_trial < self.cumulative_durs[1]
        is_samp = (not is_cue) and self.cumulative_durs[2] <= t_trial < self.cumulative_durs[3]
        if is_cue or is_samp:
            cue_loc = self.cue_locs[self.targs[trial_ix]]
            if not is_samp:
                return cue_loc
            return self.matches[trial_ix] * cue_loc
        return [0, 0]

    def ideal_signal(self, t):
        trial_ix = int(np.floor(t / self.trial_dur)) % len(self.targs)
        t_trial = t % self.trial_dur
        if t_trial >= self.cumulative_durs[-2]:
            return self.matches[trial_ix]
        return 0

    def plot_inputs(self, n_trials=3, srate=1000):
        t_vec = np.arange(0, self.trial_dur * n_trials, 1 / srate)
        plt.figure(figsize=(8, 5))
        plt.subplot(3, 1, 1)
        plt.plot(t_vec, self.gate_signal(t_vec))
        plt.ylabel('Hold')
        plt.subplot(3, 1, 2)
        plt.plot(t_vec, [self.stim_signal(_) for _ in t_vec])
        plt.ylabel('Target')
        plt.legend(['x', 'y'], loc='upper right')
        plt.subplot(3, 1, 3)
        plt.plot(t_vec, [self.ideal_signal(_) for _ in t_vec])
        plt.ylabel('Ideal')
        plt.tight_layout()


# Cell
class SpatialDMSSimple(nengo.Network):
    def __init__(self, tau=0.1, n_neurons=1000, train_trials=80):
        # Task setup
        train_trials_per_cond = int(np.ceil(train_trials / 8 / 2))
        self.dms_task = DMSTask(gen_trials_per_cond=2 * train_trials_per_cond,
                                cond_seed=1337)
        # Input Nodes
        # Fixation: -1 except during response period.
        self.fixation = nengo.Node(self.dms_task.gate_signal, size_out=1, label='fixation')
        # Target: x,y position of target.
        # Usually 0,0, or the target (sample) location during Cue (Sample).
        self.target = nengo.Node(self.dms_task.stim_signal, size_out=2, label='target')
        # Known correct answer
        self.ideal = nengo.Node(self.dms_task.ideal_signal, label='ideal')

        # SNN to do the task
        # Combines fixation (dim=0) and target inputs (dim=1,2).
        # Represents output (dim=3) as 0 when fixation high, otherwise...
        # +1 when target and sample match or -1 when mismatch
        self.do_dms = nengo.Ensemble(n_neurons=n_neurons, dimensions=4, label='do_dms', radius=2)
        nengo.Connection(self.fixation, self.do_dms[0], synapse=0.005)
        nengo.Connection(self.target, self.do_dms[1:3], transform=tau, synapse=tau)
        recurr = nengo.Connection(self.do_dms, self.do_dms,
                                  synapse=tau,
                                  learning_rule_type=nengo.PES(learning_rate=1e-4))

        # error signal = output - answer
        t_train = self.dms_task.trial_dur * train_trials
        self.error = nengo.Node(lambda t, x: (0, 0, 0, x[0]) if t <= t_train else (0, 0, 0, 0),
                                size_in=1, size_out=4, label='error')
        nengo.Connection(self.do_dms[3], self.error)
        nengo.Connection(self.ideal, self.error, transform=-1)
        nengo.Connection(self.error, recurr.learning_rule)
